---
title: "RNAseq_DESeq2"
output: html_notebook
---

First time organising R as a project/with github. Referring to this walkthrough on the topic:
https://ourcodingclub.github.io/2017/02/27/git.html

sampleTables
```{r}
sampleTableExpt1 <- read.csv("~/rnaSeqData/sampleTables/sampleTableExpt1.csv")
sampleTableExpt2 <- read.csv("~/rnaSeqData/sampleTables/sampleTableExpt2.csv")
sampleTableExpt3 <- read.csv("~/rnaSeqData/sampleTables/sampleTableExpt3.csv")
```

tximport
```{r}
source("https://bioconductor.org/biocLite.R")
biocLite("tximport")
library("tximport")

myDir <- "/home/mcity599/rnaSeqData/salmonAlignments/"
expt1Samples <- c("cag2430_1GCBias","cag2430_2GCBias","cag2430_3GCBias","cag2430_4GCBias","cag2430_5GCBias","cag2430_6GCBias")
expt1Files <- file.path(myDir,expt1Samples,"quant.sf")
names(expt1Files) <- paste0("cag2430_",1:6)
all(file.exists(expt1Files))
expt1Files

myDir <- "/home/mcity599/rnaSeqData/salmonAlignments/"
expt2Samples <- c("cag2430_7GCBias","cag2430_8GCBias","cag2430_9GCBias","cag2430_10GCBias","cag2430_11GCBias","cag2430_12GCBias")
expt2Files <- file.path(myDir,expt2Samples,"quant.sf")
names(expt2Files) <- paste0("cag2430_",7:12)
all(file.exists(expt2Files))
expt2Files

myDir <- "/home/mcity599/rnaSeqData/salmonAlignments/"
expt3Samples <- c("cag2430_13GCBias","cag2430_14GCBias","cag2430_15GCBias","cag2430_16GCBias","cag2430_17GCBias","cag2430_18GCBias")
expt3Files <- file.path(myDir,expt3Samples,"quant.sf")
names(expt3Files) <- paste0("cag2430_",13:18)
all(file.exists(expt3Files))
expt3Files


## Create a tx2gene table:
# From Xenbase I've got this:
NcbiMrnaXenbaseGene_laevis <- read.delim("~/rnaSeqData/geneConverters/NcbiMrnaXenbaseGene_laevis.txt", header=FALSE)
dim(NcbiMrnaXenbaseGene_laevis)
# The required format (for tximport) is two columns, transcript and geneID
NcbiMrnaXenbaseGene_laevis[1:5,]
transcriptToGene <- NcbiMrnaXenbaseGene_laevis[,c(2,4)]
colnames(transcriptToGene) <- c("TXNAME","GENEID") # copying the tximport vignette names

expt1TXI <- tximport(expt1Files,type = "salmon", tx2gene = transcriptToGene)
expt2TXI <- tximport(expt2Files,type = "salmon", tx2gene = transcriptToGene)
expt3TXI <- tximport(expt3Files,type = "salmon", tx2gene = transcriptToGene)
```

DESeq2
```{r}
biocLite("DESeq2")
library("DESeq2")

expt1ddsTxi <- DESeqDataSetFromTximport(expt1TXI,
                                   colData = sampleTableExpt1,
                                   design = ~ condition)
expt2ddsTxi <- DESeqDataSetFromTximport(expt2TXI,
                                   colData = sampleTableExpt2,
                                   design = ~ condition)
expt3ddsTxi <- DESeqDataSetFromTximport(expt3TXI,
                                   colData = sampleTableExpt3,
                                   design = ~ condition)
## Edit on 20180219
# While re-reading the tximport vignette I found this important piece of info:
## Note: there are two suggested ways of importing estimates for use with differential gene expression (DGE) methods. The first method, which we show below for edgeR and for DESeq2, is to use the gene-level estimated counts from the quantification tools, and additionally to use the transcript-level abundance estimates to calculate a gene-level offset that corrects for changes to the average transcript length across samples. The code examples below accomplish these steps for you, keeping track of appropriate matrices and calculating these offsets. For edgeR you need to assign a matrix to y$offset, but the function DESeqDataSetFromTximport takes care of creation of the offset for you. Let’s call this method “original counts and offset”.
# The second method is to use the tximport argument countsFromAbundance="lengthScaledTPM" or "scaledTPM", and then to use the gene-level count matrix txi$counts directly as you would a regular count matrix with these software. Let’s call this method “bias corrected counts without an offset”
# Do not do this: Do not manually pass the original gene-level counts to downstream methods without an offset. The original gene-level counts are in txi$counts when tximport was run with countsFromAbundance="no". This is simply passing the summed estimated transcript counts, and does not correct for potential differential isoform usage (the offset), which is the point of the tximport methods (Soneson, Love, and Robinson 2015) for gene-level analysis. Passing uncorrected gene-level counts without an offset is not recommended by the tximport package authors. The two methods we provide here are: “original counts and offset” or “bias corrected counts without an offset”. Passing txi to DESeqDataSetFromTximport as outlined below is correct: the function creates the appropriate offset for you to perform gene-level differential expression.
## I hadn't noticed this when I first did it, but fortunately I had used the correct function anyway (due to the tximport vignette being well written)

# Pre-filtering ( copied from the DESeq2 walkthrough)
# While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful: by removing rows in which there are very few reads, we reduce the memory size of the dds data object, and we increase the speed of the transformation and testing functions within DESeq2. Here we perform a minimal pre-filtering to keep only rows that have at least 10 reads total. Note that more strict filtering to increase power is automatically applied via independent filtering on the mean of normalized counts within the results function.
keep <- rowSums(counts(expt1ddsTxi)) >= 10
ddsExpt1 <- expt1ddsTxi[keep,]
keep <- rowSums(counts(expt2ddsTxi)) >= 10
ddsExpt2 <- expt2ddsTxi[keep,]
keep <- rowSums(counts(expt3ddsTxi)) >= 10
ddsExpt3 <- expt3ddsTxi[keep,]
rm(keep)

ddsExpt1$condition

ddsExpt1 <- DESeq(ddsExpt1)
ddsExpt2 <- DESeq(ddsExpt2)
ddsExpt3 <- DESeq(ddsExpt3)
# For the sake of size/tidy workspace, I'll remove the objects needed to make ddsExpt 
rm(expt1ddsTxi)
rm(expt2ddsTxi)
rm(expt3ddsTxi)
rm(expt1TXI)
rm(expt2TXI)
rm(expt3TXI)

# LFC shrinkage for transcripts with low read counts:
 # Full methods are described in the DESeq2 paper (see DESeq2 citation), but in short, it looks at the largest fold changes that are not due to low counts and uses these to inform a prior distribution. So the large fold changes from genes with lots of statistical information are not shrunk, while the imprecise fold changes are shrunk. This allows you to compare all estimated LFC across experiments, for example, which is not really feasible without the use of a prior.
#  - https://support.bioconductor.org/p/77461/
resultsNames(ddsExpt1)
resLFCexpt1 <- lfcShrink(ddsExpt1, coef=2)
resLFCexpt2 <- lfcShrink(ddsExpt2, coef=2)
resLFCexpt3 <- lfcShrink(ddsExpt3, coef=2)

rm(ddsExpt1)
rm(ddsExpt2)
rm(ddsExpt3)

# Trim to include only statistically significant results:
statSigExpt1 <- subset(resLFCexpt1, padj < 0.05)
statSigExpt2 <- subset(resLFCexpt2, padj < 0.05)
statSigExpt3 <- subset(resLFCexpt3, padj < 0.05)

# Pull out only genes with biologically significant (i.e., log2FC >1 or < - 1) differences:
Expt1_upregInB <- rownames(statSigExpt1[order(statSigExpt1$log2FoldChange, decreasing = TRUE)[1:sum(statSigExpt1$log2FoldChange > 1, na.rm=T)], ])
Expt1_downregInB <- rownames(statSigExpt1[order(statSigExpt1$log2FoldChange, decreasing = F)[1:sum(statSigExpt1$log2FoldChange < -1, na.rm=T)], ])

Expt2_upregInB <- rownames(statSigExpt2[order(statSigExpt2$log2FoldChange, decreasing = TRUE)[1:sum(statSigExpt2$log2FoldChange > 1, na.rm=T)], ])
Expt2_downregInB <- rownames(statSigExpt2[order(statSigExpt2$log2FoldChange, decreasing = F)[1:sum(statSigExpt2$log2FoldChange < -1, na.rm=T)], ])

Expt3_upregInB <- rownames(statSigExpt3[order(statSigExpt3$log2FoldChange, decreasing = TRUE)[1:sum(statSigExpt3$log2FoldChange > 1, na.rm=T)], ])
Expt3_downregInB <- rownames(statSigExpt3[order(statSigExpt3$log2FoldChange, decreasing = F)[1:sum(statSigExpt3$log2FoldChange < -1, na.rm=T)], ])
```

Convert these up and downregulated gene names to something that can go through PANTHER
```{r}
XenbaseGenepageToGeneIdMapping <- read.delim("~/rnaSeqData/geneConverters/XenbaseGenepageToGeneIdMapping.txt", header=FALSE)
# readme:
##File contains the mapping of XB-GENEPAGE IDs, the primary identifier for a genepage to XB-GENE IDs for individual tropicalis and laevis genes.
##The file is tab-delimited and has the following format:
    #Xenbase genepage ID
    #Xenbase Gene IDs

# The ID in these next vectors is a sort of 'basal gene name', from which the names given to the transcript originates. e.g., the first gene in the following file is "nog", but prior to conversion is "nog.L" (which I know refers to the "long" chromosome in the X.laevis genome). This ".L" prevents any mapping
expt1_geneConversionUp <- as.vector(na.omit(XenbaseGenepageToGeneIdMapping[match(NcbiMrnaXenbaseGene_laevis[as.vector(na.omit(match(Expt1_upregInB,NcbiMrnaXenbaseGene_laevis[,4]))),3],XenbaseGenepageToGeneIdMapping[,5]),2]))
expt1_geneConversionDown <- as.vector(na.omit(XenbaseGenepageToGeneIdMapping[match(NcbiMrnaXenbaseGene_laevis[as.vector(na.omit(match(Expt1_downregInB,NcbiMrnaXenbaseGene_laevis[,4]))),3],XenbaseGenepageToGeneIdMapping[,5]),2]))

expt2_geneConversionUp <- as.vector(na.omit(XenbaseGenepageToGeneIdMapping[match(NcbiMrnaXenbaseGene_laevis[as.vector(na.omit(match(Expt2_upregInB,NcbiMrnaXenbaseGene_laevis[,4]))),3],XenbaseGenepageToGeneIdMapping[,5]),2]))
expt2_geneConversionDown <- as.vector(na.omit(XenbaseGenepageToGeneIdMapping[match(NcbiMrnaXenbaseGene_laevis[as.vector(na.omit(match(Expt2_downregInB,NcbiMrnaXenbaseGene_laevis[,4]))),3],XenbaseGenepageToGeneIdMapping[,5]),2]))

expt3_geneConversionUp <- as.vector(na.omit(XenbaseGenepageToGeneIdMapping[match(NcbiMrnaXenbaseGene_laevis[as.vector(na.omit(match(Expt3_upregInB,NcbiMrnaXenbaseGene_laevis[,4]))),3],XenbaseGenepageToGeneIdMapping[,5]),2]))
expt3_geneConversionDown <- as.vector(na.omit(XenbaseGenepageToGeneIdMapping[match(NcbiMrnaXenbaseGene_laevis[as.vector(na.omit(match(Expt3_downregInB,NcbiMrnaXenbaseGene_laevis[,4]))),3],XenbaseGenepageToGeneIdMapping[,5]),2]))

length(expt1_geneConversionDown)
length(expt1_geneConversionUp)
length(expt2_geneConversionDown)
length(expt2_geneConversionUp)
length(expt3_geneConversionDown)
length(expt3_geneConversionUp)


# The vectors above could essentially be used, but the conversion below filters for only genes with a human Ortholog - it tends to cut out all locXXXX transcripts. As far as I've been able to see with my eye, this is all that it does. 
XenbaseGeneHumanOrthologMapping <- read.delim("~/rnaSeqData/geneConverters/XenbaseGeneHumanOrthologMapping.txt", header=FALSE)

DownregGenes_expt1 <- as.vector(XenbaseGeneHumanOrthologMapping[as.vector(na.omit(match(expt1_geneConversionDown,as.vector(XenbaseGeneHumanOrthologMapping[,3])))),3])
length(DownregGenes_expt1)
length(expt1_geneConversionDown)

UpregGenes_expt1 <- as.vector(XenbaseGeneHumanOrthologMapping[as.vector(na.omit(match(expt1_geneConversionUp,as.vector(XenbaseGeneHumanOrthologMapping[,3])))),3])
length(UpregGenes_expt1)

DownregGenes_expt2 <- as.vector(XenbaseGeneHumanOrthologMapping[as.vector(na.omit(match(expt2_geneConversionDown,as.vector(XenbaseGeneHumanOrthologMapping[,3])))),3])
UpregGenes_expt2 <- as.vector(XenbaseGeneHumanOrthologMapping[as.vector(na.omit(match(expt2_geneConversionUp,as.vector(XenbaseGeneHumanOrthologMapping[,3])))),3])

DownregGenes_expt3 <- as.vector(XenbaseGeneHumanOrthologMapping[as.vector(na.omit(match(expt3_geneConversionDown,as.vector(XenbaseGeneHumanOrthologMapping[,3])))),3])
UpregGenes_expt3 <- as.vector(XenbaseGeneHumanOrthologMapping[as.vector(na.omit(match(expt3_geneConversionUp,as.vector(XenbaseGeneHumanOrthologMapping[,3])))),3])

getwd()
write.csv(DownregGenes_expt1,file="DownregGenes_expt1.csv",row.names=F,col.names = F)
write.csv(DownregGenes_expt2,file="DownregGenes_expt2.csv",row.names=F,col.names = F)
write.csv(DownregGenes_expt2,file="DownregGenes_expt3.csv",row.names=F,col.names = F)

write.csv(UpregGenes_expt1,file="UpregGenes_expt1.csv",row.names=F,col.names = F)
write.csv(UpregGenes_expt2,file="UpregGenes_expt2.csv",row.names=F,col.names = F)
write.csv(UpregGenes_expt3,file="UpregGenes_expt3.csv",row.names=F,col.names = F)

# Tidy up by removing the large objects involve in these conversions:
rm(NcbiMrnaXenbaseGene_laevis)
rm(XenbaseGeneHumanOrthologMapping)
rm(XenbaseGenepageToGeneIdMapping)
```



20180219
==========================================================================================================================================================

Two jobs: 
1. Use EdgeR to generate a new list of diff expressed genes. Can use the DE expt overlap between DESEq2 and EdgeR for a more robust analysis. 
2. Overlap EdgeR/DESeq2
  2.1 Might need to adjust the Expt1 parameters at this point, since Expt1 had very few DE genes - C states this may be due to the noisy nature of the experimental comparison. 
  


```{r}
source("https://bioconductor.org/biocLite.R")
biocLite("BiocUpgrade")

biocLite("edgeR")
library("edgeR")
# Consulting the edgeR user guide: https://www.bioconductor.org/packages/devel/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf
# Two modules incorporated: classic (exact statistical models for multiple groups) and glm (generalised linear models). Both use empirical Bayes to estimate gene-specific biological variation
### EdgeR has a specific citation request, asking that citations are done (in addition to EdgeR) for the specific commands - i.e., it lists a bunch of papers with the various commands they have derived and asks for specific citation of these papers. 

# Within glm are two sub-modules: likelihood ratio test and quasi-likelihood F-test. Guide recommends the quasi-likelihood F-test for any bulk RNA-seq experiment, which uses a stricter error rate which can account for uncertainty in dispersion estimate (??). 
```

Reading counts from a file:
```{r}
# The formula: y <- DGEList(counts=x)
```
At this point, I assumed expt1TXI (search above) was the object I'm after. It contains the 'count' info. 
To re-familiarise myself with the TXI object I looked at the tximport vignette (https://bioconductor.org/packages/3.7/bioc/vignettes/tximport/inst/doc/tximport.html#edger)
Found this quick walkthrough:

cts <- txi$counts
normMat <- txi$length
normMat <- normMat/exp(rowMeans(log(normMat)))
library(edgeR)
o <- log(calcNormFactors(cts/normMat)) + log(colSums(cts/normMat))
y <- DGEList(cts)
y$offset <- t(t(log(normMat)) + o)
y is now ready for estimate dispersion functions see edgeR User's Guide

```{r}
expt1TXI <- tximport(expt1Files,type = "salmon", tx2gene = transcriptToGene)
expt2TXI <- tximport(expt2Files,type = "salmon", tx2gene = transcriptToGene)
expt3TXI <- tximport(expt3Files,type = "salmon", tx2gene = transcriptToGene)
length(expt1TXI)
names(expt1TXI)
# abundance, counts, length, countsFromAbundance

# Using the above framework:
cts <- expt1TXI$counts
normMat <- expt1TXI$length
normMat <- normMat/exp(rowMeans(log(normMat)))
library(edgeR)
o <- log(calcNormFactors(cts/normMat)) + log(colSums(cts/normMat))
y <- DGEList(cts)
y$offset <- t(t(log(normMat)) + o)
edgeR_Y_expt1 <- y

cts <- expt2TXI$counts
normMat <- expt2TXI$length
normMat <- normMat/exp(rowMeans(log(normMat)))
library(edgeR)
o <- log(calcNormFactors(cts/normMat)) + log(colSums(cts/normMat))
y <- DGEList(cts)
y$offset <- t(t(log(normMat)) + o)
edgeR_Y_expt2 <- y

cts <- expt3TXI$counts
normMat <- expt3TXI$length
normMat <- normMat/exp(rowMeans(log(normMat)))
library(edgeR)
o <- log(calcNormFactors(cts/normMat)) + log(colSums(cts/normMat))
y <- DGEList(cts)
y$offset <- t(t(log(normMat)) + o)
edgeR_Y_expt3 <- y

# Tidy up
rm(y)
rm(cts)
rm(normMat)
rm(o)

edgeR_Y_expt1$samples
# Lacks info about which group they are in
edgeR_Y_expt1$samples$group <- c(rep("1",3),rep("2",3))
edgeR_Y_expt1$samples
edgeR_Y_expt2$samples$group <- c(rep("1",3),rep("2",3))
edgeR_Y_expt3$samples$group <- c(rep("1",3),rep("2",3))

```


RNA-seq provides a measure of the relative abundance of each gene in each RNA sample, but does
not provide any measure of the total RNA output on a per-cell basis.  This commonly becomes
important  when  a  small  number  of  genes  are  very  highly  expressed  in  one  sample,  but  not  in
another.  The highly expressed genes can consume a substantial proportion of the total library size,
causing the remaining genes to be under-sampled in that sample.  Unless this
RNA  composition
effect is adjusted for, the remaining genes may falsely appear to be down-regulated in that sample
[30].
The
calcNormFactors
function normalizes for RNA composition by finding a set of scaling factors
for the library sizes that minimize the log-fold changes between the samples for most genes.  The
default method for computing these scale factors uses a trimmed mean of M-values (TMM) between
each pair of samples [30].  We call the product of the original library size and the scaling factor the
effective  library  size
.  The effective library size replaces the original library size in all downsteam
analyses.
TMM  is  the  recommended  for  most  RNA-Seq  data  where  the  majority  (more  than  half)  of
the genes are believed not differentially expressed between any pair of the samples.  The following
commands perform the TMM normalization and display the normalization factors.
# y <- calcNormFactors(y)
# y$samples
```{r}
edgeR_Y_expt1 <- calcNormFactors(edgeR_Y_expt1)
edgeR_Y_expt1$samples

edgeR_Y_expt2 <- calcNormFactors(edgeR_Y_expt2)
edgeR_Y_expt2$samples

edgeR_Y_expt3 <- calcNormFactors(edgeR_Y_expt3)
edgeR_Y_expt3$samples
```



Pairwise comparison between two groups
----------------------------------------
Estimating dispersions:
A glm (generalised linear model) estimates probabiblity distributions according to their mean-variance relationship. This first involves calculating "dispersion". 

```{r}
# y <- estimateDisp(y, design)
# To create the design object:

designExpt1 <- model.matrix(~0+group, data=edgeR_Y_expt1$samples)
colnames(designExpt1) <- c("A","B")
designExpt2 <- model.matrix(~0+group, data=edgeR_Y_expt2$samples)
colnames(designExpt1) <- c("A","B")
designExpt3 <- model.matrix(~0+group, data=edgeR_Y_expt3$samples)
colnames(designExpt1) <- c("A","B")

edgeR_dispersion_expt1 <- estimateDisp(edgeR_Y_expt1,designExpt1)
edgeR_dispersion_expt2 <- estimateDisp(edgeR_Y_expt2,designExpt2)
edgeR_dispersion_expt3 <- estimateDisp(edgeR_Y_expt3,designExpt3)
```

# Now ready to test for DE genes using a linear model approach:
```{r}
fitExpt1 <- glmQLFit(edgeR_dispersion_expt1, designExpt1)
fitExpt2 <- glmQLFit(edgeR_dispersion_expt2, designExpt2)
fitExpt3 <- glmQLFit(edgeR_dispersion_expt3, designExpt3)

BvsA <- makeContrasts(B-A, levels=designExpt1)
# Which is the same for experiments 2 and 3
BvsA

glmResultExpt1 <- glmQLFTest(fitExpt1, contrast=BvsA)
glmResultExpt2 <- glmQLFTest(fitExpt2, contrast=BvsA)
glmResultExpt3 <- glmQLFTest(fitExpt3, contrast=BvsA)

topTags(glmResultExpt1)
?topTags
topTags(glmResultExpt1,adjust.method = "BH", sort.by = "logFC")
# there should be a way to retrieve all tags with p values < 0.05:
glmExpt1_p05 <- topTags(glmResultExpt1,p.value = 0.05)
dim(glmExpt1_p05)
# Doesn't work, only returns the top 10. 

topTags(glmResultExpt1,n=100)
# This can retrieve as many as specified:
topTags(glmResultExpt1)
glmExpt1_p05 <- topTags(glmResultExpt1,n=50000,adjust.method="BH",p.value = 0.05) # where n is any number larger than the number of genes with P < 0.05
glmExpt2_p05 <- topTags(glmResultExpt2,n=50000,adjust.method="BH",p.value = 0.05)
glmExpt3_p05 <- topTags(glmResultExpt3,n=50000,adjust.method="BH",p.value = 0.05)

# Pull out only genes which are also biologically (log2FC)
## The help page for glmLRT says: "The data frame table contains the following columns: logFC: log2-fold change of expression between conditions being tested." so I know I'm working oin log2FC. (https://support.bioconductor.org/p/50273/)
colnames(glmExpt1_p05)
edgerSigResultsUpRegExpt1 <- glmExpt1_p05[order(glmExpt1_p05$table$logFC,decreasing=T)[1:sum(sort(glmExpt1_p05$table$logFC,decreasing=T) >1,na.rm=T)],]
edgerSigResultsUpRegExpt1[1:20,]
edgerSigResultsDownRegExpt1 <- glmExpt1_p05[order(glmExpt1_p05$table$logFC,decreasing=F)[1:sum(sort(glmExpt1_p05$table$logFC,decreasing=F) < -1,na.rm=T)],]
edgerSigResultsDownRegExpt1[1:20,]

grep("nog",rownames(edgerSigResultsDownRegExpt1))
grep("nog",rownames(edgerSigResultsUpRegExpt1))

dim(edgerSigResultsDownRegExpt1)
dim(edgerSigResultsUpRegExpt1)

# Expt2
edgerSigResultsUpRegExpt2 <- glmExpt2_p05[order(glmExpt2_p05$table$logFC,decreasing=T)[1:sum(sort(glmExpt2_p05$table$logFC,decreasing=T) >1,na.rm=T)],]
edgerSigResultsUpRegExpt2[1:20,]
edgerSigResultsDownRegExpt2 <- glmExpt2_p05[order(glmExpt2_p05$table$logFC,decreasing=F)[1:sum(sort(glmExpt2_p05$table$logFC,decreasing=F) < -1,na.rm=T)],]
edgerSigResultsDownRegExpt2[1:20,]
dim(edgerSigResultsDownRegExpt2)
dim(edgerSigResultsUpRegExpt2)

# Expt3
edgerSigResultsUpRegExpt3 <- glmExpt3_p05[order(glmExpt3_p05$table$logFC,decreasing=T)[1:sum(sort(glmExpt3_p05$table$logFC,decreasing=T) >1,na.rm=T)],]
edgerSigResultsUpRegExpt3[1:20,]
edgerSigResultsDownRegExpt3 <- glmExpt3_p05[order(glmExpt3_p05$table$logFC,decreasing=F)[1:sum(sort(glmExpt3_p05$table$logFC,decreasing=F) < -1,na.rm=T)],]
edgerSigResultsDownRegExpt3[1:20,]
dim(edgerSigResultsDownRegExpt3)
dim(edgerSigResultsUpRegExpt3)

getwd()
# Will manually transfer to EdgeR_diffExpressedGenes
write.csv(edgerSigResultsUpRegExpt1,file='edgerSigResultsUpRegExpt1.csv')
write.csv(edgerSigResultsUpRegExpt2,file='edgerSigResultsUpRegExpt2.csv')
write.csv(edgerSigResultsUpRegExpt3,file='edgerSigResultsUpRegExpt3.csv')

write.csv(edgerSigResultsDownRegExpt1,file='edgerSigResultsDownRegExpt1.csv')
write.csv(edgerSigResultsDownRegExpt2,file='edgerSigResultsDownRegExpt2.csv')
write.csv(edgerSigResultsDownRegExpt3,file='edgerSigResultsDownRegExpt3.csv')
```





